# 查找左边界

> 给定一个长度为 n 的有序数组 `nums` ，其中可能包含重复元素。请返回数组中最左一个元素 `target` 的索引。若数组中不包含该元素，则返回 −1 。

回忆二分查找插入点的方法，搜索完成后 l 指向最左一个 `target` ，**因此查找插入点本质上是在查找最左一个 `target` 的索引**。

考虑通过查找插入点的函数实现查找左边界。请注意，数组中可能不包含 `target` ，这种情况可能导致以下两种结果。

- 插入点的索引 `l` 越界。
- 元素 `nums[i]` 与 `target` 不相等。

当遇到以上两种情况时，直接返回 −1 即可

# 查找右边界

那么如何查找最右一个 `target` 呢？最直接的方式是修改代码，替换在 `nums[mid] == target` 情况下的指针收缩操作

```c++
if(nums[mid] == target) {
	l = mid + 1;
}
```

实际上，我们可以利用查找最左元素的函数来查找最右元素，具体方法为：**将查找最右一个 `target` 转化为查找最左一个 `target + 1`**。

查找完成后，指针 `l` 指向最左一个 `target + 1`（如果存在），而 `r` 指向最右一个 `target` ，**因此返回 r 即可**。

请注意，返回的插入点是` l `，因此需要将其减 1 ，从而获得 `r` 