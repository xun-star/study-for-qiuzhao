# 二叉树的堂兄弟节点

[题目链接](https://leetcode.cn/problems/cousins-in-binary-tree/)

> 解题思路
>
> 1. 题目要求我们找到`x和y`处于同样的深度，但是父节点不同，返回true，否则返回false
> 2. dfs()函数参数解读
>    1. TreeNode*root:是此时正要处理的节点
>    2. int x:表示我们要寻找的`x和y`
>    3. int fa：表示正在处理的节点的父节点的值
>    4. int depth：表示此时正在处理的节点的深度
> 3. dfs()函数返回一个数组，第一个值是目标节点的父节点的值，第二个值是目标节点的深度
> 4. 如果说当前处理的节点为空，那么直接返回{0，0}
> 5. 如果找到目标节点，则返回父节点和深度{fa,depth}
> 6. 之后就是递归左子树和右子树，深度+1，父节点为当前节点的值
> 7. 其实，左右子树递归时，只有一个子树包含目标值(因为所有的值只会出现一次)，另一个子树返回{0,0}
> 8. 所以最后返回`{l[0]+r[0],l[1]+r[1]};`

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> dfs(TreeNode* root,int x,int fa,int depth){
        if(!root) return {0,0};
        if(root->val == x) return {fa,depth};
        auto l = dfs(root->left,x,root->val,depth+1);
        auto r = dfs(root->right,x,root->val,depth+1);
        return {l[0]+r[0],l[1]+r[1]};
    }
    bool isCousins(TreeNode* root, int x, int y) {
        auto a = dfs(root,x,-1,0);
        auto b = dfs(root,y,-1,0);
        if(a[0] != b[0] && a[1] ==b[1]){
            return true;
        }else{
            return false;
        }
    }
};
```

