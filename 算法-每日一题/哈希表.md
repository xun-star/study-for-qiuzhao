# 统计出现过一次的公共字符串

* [题目链接](https://leetcode.cn/problems/count-common-words-with-one-occurrence/description/)

>
>
>解题思路：
>
>显然我们需要统计每个字符串数组中每个字符串出现的字数
>
>使用哈希表key表示字符产，val用来记录该字符串出现的次数
>
>最后遍历map1，要找到每个字符串只出现一次，并且在两个字符串数组中都出现
>
>`i.second == 1 && map2[i.first] == 1`即可进行判断

```c++
class Solution {
public:
    int countWords(vector<string>& words1, vector<string>& words2) {
        int res = 0;
        unordered_map<string,int> map1;
        unordered_map<string,int> map2;
        for(auto &word : words1){
            map1[word]++;
        }
        for(auto &word : words2){
            map2[word]++;
        }
        for(auto &i : map1){
            if(i.second == 1 && map2[i.first] == 1) res++;
        }
        return res;
    }
};
```

# 有效字母的异位词

[题目链接](https://leetcode.cn/problems/valid-anagram/)

>
>
>解题思路：
>
>1. 遍历两个字符串，统计每个字符串出现的字数
>2. 遍历两个字符串，比较两个字符串中某个字符出现的次数是否相等

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        unordered_map<char,int> maps;
        unordered_map<char,int> mapt;
        bool ans = true;
        for(int i = 0;i<s.length();i++){
            maps[s[i]]++;
        }

        for(int i = 0;i<t.length();i++){
            mapt[t[i]]++;
        }
        
        for(int i = 0,j=0;i<s.length() || j < t.length();i++,j++){
            if(maps[s[i]] != mapt[s[i]] || maps[t[j]] != mapt[t[j]]){
                ans = false;
                break;
            }
        }

        return ans;
    }
}
```
